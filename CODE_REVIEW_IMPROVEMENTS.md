# Анализ проекта: предложения по улучшению

Аудит по направлениям: **производительность**, **читабельность**, **SOLID**, **DRY**.

---

## 1. Производительность

### 1.1 Binance API — последовательные запросы
**Где:** `App\Service\Binance\BinancePriceService::getAvgPrices()`  
**Проблема:** Цены по символам запрашиваются в цикле по одному. При 3 символах — 3 последовательных HTTP-запроса, время ≈ сумма задержек.  
**Предложение:** Использовать асинхронные запросы Symfony HttpClient (`HttpClientInterface::request()` в цикле без await, затем `Response::getStatusCode()`/`toArray()` при итерации) или `HttpClient::request()` с массивом запросов и `stream()`/`yield`, чтобы выполнять запросы параллельно и сократить время до одного RTT.

### 1.2 Кэширование логгеров LogManager
**Где:** `App\Service\LogManager::getLogger()`  
**Проблема:** При каждом вызове создаётся новый `Logger`, новый `StreamHandler` или анонимный DB handler. В команде снапшота вызывается дважды `getLogger('events', 'db')` — два набора handler’ов.  
**Предложение:** Кэшировать экземпляры логгеров по ключу `$name . '|' . $type` (в памяти), чтобы один и тот же логгер переиспользовался.

### 1.3 Запрос к БД в AppLogReader
**Где:** `App\Service\AppLogReader::getRecentEvents()`  
**Проблема:** LIMIT подставляется через конкатенацию (хоть и с `(int)` — безопасно). Для больших лимитов запрос без пагинации может отдавать много строк.  
**Предложение:** Оставить как есть для текущего масштаба; при росте — ввести курсор/пагинацию по `id` или `created_at` и индекс по `(channel, created_at)`.

### 1.4 Portfolio history — лимит выборки
**Где:** `PortfolioSnapshotRepository::findForHistory()`  
**Проблема:** Нет ограничения количества записей. При `hours=720` (30 дней по часу) вернётся до 720 сущностей; при minute granularity — гораздо больше.  
**Предложение:** Явный `setMaxResults()` в репозитории или на уровне конфига (уже есть `max_hours`), плюс при необходимости — пагинация или ответ в формате «агрегат по часу», чтобы не тянуть все минуты.

### 1.5 HTTP Cache для read-only API
**Где:** `PortfolioHistoryController`, `EventsController`  
**Проблема:** Сейчас только `Cache-Control: no-store, no-cache, must-revalidate` — данные не кэшируются.  
**Предложение:** Для истории портфеля за прошлые периоды (например, когда `to < now`) можно выдавать короткий `max-age` (например 60–300 сек) или использовать Symfony HTTP Cache / Varnish для снижения нагрузки на БД.

---

## 2. Читабельность

### 2.1 Парсинг параметров в PortfolioHistoryController
**Где:** `PortfolioHistoryController::index()`  
**Проблема:** Большая цепочка if/elseif по `from`/`to`, `hours`, `minutes` и валидация в одном методе — трудно читать и тестировать.  
**Предложение:** Вынести разбор query-параметров в отдельный сервис или value object (например `PortfolioHistoryRequest`), возвращающий нормализованные `$from`, `$to` или ошибку валидации. В контроллере — один вызов и обработка результата.

### 2.2 Магические ключи amounts/symbols
**Где:** `portfolio.amounts` (btc, eth, sol, usdt) и `binance.symbols` (BTCUSDT, …)  
**Проблема:** Связь «btc → BTCUSDT» захардкожена в коде в нескольких местах; при добавлении актива нужно править и конфиг, и код.  
**Предложение:** Ввести один конфиг «asset → symbol» (или маппинг lowercase → symbol) и один источник правды; в коде — итерация по этому маппингу вместо перечисления btc/eth/sol.

### 2.3 Именование метода репозитория
**Где:** `PortfolioSnapshotRepository::findForHistory($from, $to, $hours)`  
**Проблема:** Поведение переключается по `$hours !== null`: при переданном `$hours` аргументы `$from`/`$to` игнорируются. Неочевидно по сигнатуре.  
**Предложение:** Либо два метода (`findByRange(DateTime $from, DateTime $to)` и `findLastHours(int $hours)`), либо явный комментарий/контракт: «если hours задан, from/to не используются».

### 2.4 Константа формата даты
**Где:** В нескольких местах: `'Y-m-d\TH:i:sP'` для API.  
**Проблема:** Строка дублируется (Command, Controller, …).  
**Предложение:** Вынести в общую константу (например в сущность или в отдельный класс форматов API) и использовать везде.

### 2.5 Уровень логирования в LogManager для `app`
**Где:** `LogManager::getLogger('app', 'file')`  
**Проблема:** Для канала `app` пишется только в `errors.log` с уровнем Error. Название параметра `$name` и поведение по умолчанию неочевидны из имени.  
**Предложение:** Уточнить в PHPDoc или переименовать: например, явно указать, что `name=app` означает «только ошибки в errors.log».

---

## 3. SOLID

### 3.1 Единая ответственность (SRP)
**Где:** `PortfolioSnapshotCommand`  
**Проблема:** Команда и расчёт снапшота, и логирование в два канала, и публикация в Mercure, и подмена payload при дубликате. Много обязанностей в одном классе.  
**Предложение:** Вынести «после снапшота: логировать + отправить в Mercure» в отдельный сервис (например `PortfolioSnapshotNotifier` или listener), команда только вызывает `PortfolioValuationService::snapshot()` и этот сервис.

### 3.2 Зависимость от абстракций (DIP)
**Где:** В целом проект уже использует `BinancePriceServiceInterface` — хорошо.  
**Замечание:** `LogManager` возвращает `LoggerInterface`, но внутри создаёт конкретный `Monolog\Logger` и handler’ы. Для тестов можно завести интерфейс «получить логгер по имени/типу» и подменять реализацию.

### 3.3 Открытость/закрытость (OCP)
**Где:** `PortfolioValuationService`, `PortfolioBreakdownController`  
**Проблема:** Добавление нового актива (например XRP) требует правки кода: новые ключи в `$amounts`, новые ветки для цен.  
**Предложение:** Расчёт портфеля строить по конфигу: пары (symbol, amount) и одна формула в цикле; конфиг задаёт состав портфеля, код не меняется при добавлении актива.

### 3.4 Разделение интерфейсов (ISP)
**Где:** Нет избыточных интерфейсов — интерфейс Binance один и узкий. Ок.

---

## 4. DRY

### 4.1 Формула стоимости портфеля
**Где:** `PortfolioValuationService::snapshot()` и `PortfolioBreakdownController::index()`  
**Проблема:** Расчёт total_usdt и разбивка по активам повторяют одну и ту же логику: amount × price по символам, плюс USDT.  
**Предложение:** Вынести расчёт в один сервис или метод (например `PortfolioValuationService::calculateFromPrices(array $prices): array` с полем `total` и полем `breakdown` по символам). Breakdown-контроллер тогда только запрашивает цены, вызывает этот метод и форматирует JSON.

### 4.2 Маппинг symbol → amount
**Где:** Конфиг: `portfolio.amounts` (btc, eth, sol) и `binance.symbols` (BTCUSDT, …). В коде — явное сопоставление btc→BTCUSDT, eth→ETHUSDT, sol→SOLUSDT.  
**Предложение:** Один параметр, например `portfolio.holdings`: `{ BTCUSDT: 1, ETHUSDT: 10, SOLUSDT: 50, USDT: 5000 }` (или список пар), чтобы не дублировать связь ключ→symbol в нескольких классах.

### 4.3 Формат ответа снапшота (time + amount_usdt)
**Где:** `PortfolioSnapshotCommand` (формирование payload из сущности), `PortfolioHistoryController` (маппинг сущности в элемент массива).  
**Проблема:** Формат `['calculated_at' => …, 'amount_usdt' => …]` собирается вручную в двух местах.  
**Предложение:** Метод на сущности или в DTO, например `PortfolioSnapshot::toApiPayload(): array`, и использовать его в команде и в контроллере (или в сериализаторе).

### 4.4 Логирование в команде
**Где:** `PortfolioSnapshotCommand::execute()`  
**Проблема:** Один и тот же контекст пишется в `$this->logger` и в `$this->logManager->getLogger('events', 'db')` двумя вызовами.  
**Предложение:** Один вспомогательный метод вида `logSnapshotResult(?array $data): void`, который пишет в оба логгера, или один канал с несколькими handler’ами в конфиге Monolog.

### 4.5 Обработка ошибок в команде
**Где:** Блоки catch для `BinanceApiException` и `\Throwable` дублируют структуру: вывод в консоль, logger, logManager, io->error, return FAILURE.  
**Предложение:** Вынести в приватный метод `handleFailure(\Throwable $e, string $type): int` с параметром типа ошибки (Binance / other).

---

## 5. Дополнительно (без привязки к категориям)

### 5.1 Типизация конфига amounts
**Где:** PHPDoc `array{btc: int|float, ...}`  
**Проблема:** В `portfolio.yaml` используются `int` и `float` для USDT; консистентность типов в конфиге и в коде.  
**Предложение:** Везде в коде приводить к `(float)` (уже есть), в PHPDoc можно оставить `array<string, float>` если перейти на единый маппинг symbol→amount.

### 5.2 Репозиторий — final
**Где:** `PortfolioSnapshotRepository`  
**Замечание:** Класс не объявлен `final`; сервисы в основном `final`. Для консистентности и запрета наследования репозиториев можно пометить `final`.

### 5.3 EntityManager::clear() при UniqueConstraintViolation
**Где:** `PortfolioValuationService::snapshot()`  
**Проблема:** После `clear()` все сущности, управляемые EM, открепляются. Если в том же запросе/команде что-то ещё работало с EM, возможны неочевидные эффекты.  
**Предложение:** Вызывать `clear()` только если уверены, что контекст — один запрос/одна команда; либо сбрасывать только эту сущность через `UnitOfWork::detach($snapshot)`.

### 5.4 BinancePriceService — повторный throw
**Где:** `catch (BinanceApiException $e) { throw $e; }`  
**Предложение:** Можно убрать этот catch и дать исключению всплывать; оставить только catch `\Throwable` и оборачивать в `BinanceApiException`. Так меньше дублирования.

---

## Сводка приоритетов

| Приоритет | Что делать |
|-----------|------------|
| Высокий   | DRY: один сервис расчёта портфеля; один маппинг symbol→amount в конфиге. |
| Высокий   | Производительность: параллельные запросы к Binance. |
| Средний   | Читабельность: вынести парсинг history-параметров в отдельный объект/сервис. |
| Средний   | SRP: вынести логику «логировать + Mercure» из команды в отдельный сервис. |
| Низкий    | Кэш логгеров в LogManager; константа формата даты; final для репозитория. |

Файл можно использовать как чек-лист при рефакторинге.
